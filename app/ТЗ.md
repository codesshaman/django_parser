## Техническое задание. Реализация web-приложения для парсинга сайта zakupki.gov

Необходимо реализовать  web-приложение для парсинга данных о государственных закупках с сайта zakupki.gov

### Общие требования
- Программа должна быть разработана на языке Python
- При написании кода необходимо придерживаться Google Code Style
- Необходимо разработать Web-приложение, работающее по Rest API  (см. часть 1)
- Программа должна быть реализована с использованием MVC-фреймворка Django
- Должна использоваться стандартная база данных SQLite
- Программа должна быть реализована с использованием паттерна **MVC**, а также: 
    - не должно быть кода бизнес-логики в коде представлений;
    - не должно быть кода интерфейса в контроллере и в модели;
    - контроллеры должны быть тонкими;
- API должно версионироваться
- Модули разных версий должны иметь в названии версию API
- Необходимо разработать Web-приложение, работающее c GUI (см. часть 2)
- Обработка всех запросов происходит на стороне сервера (включая **Server-Side Rendering**)
- В качестве референса по дизайну можно использовать стиль bootstrap или возможности Django
- Дизайн графической части приложения должен быть интуитивно-понятным

## Преамбула
### Цели и задачи

Необходимо разработать приложение, осуществляющее парсинг по API данных о закупке с сайта федеральных закупок zakupki.gov.
Заказчику необходим парсинг закупок по федеральному закону 44 (в дальнейшем - ФЗ44) и федеральному закону 223 (ФЗ223).
Парсинг ФЗ44 можно осуществлять непосредственно через XML по следующей ссылке:

```
https://zakupki.gov.ru/epz/order/notice/printForm/viewXml.html?regNumber=0115300018518000004
```

Сложность проекта заключается в том, что для парсинга ФЗ223 подобные актуальные XML формируются в очень разнородном виде
и только через сутки после появления самой закупки на сайте. Заказчику необходим парсинг онлайн, поэтому вдобавок к модулю
парсинга ФЗ44 необходимо разработать модуль парсинга ФЗ223, который будет извлекать весьма разнородную информацию уже
непосредственно с сайта госзакупок. И здесь мы сталкиваемся с рядом проблем:

#### Проблема 1. Разнородность данных

Так как закупки типа ФЗ223 формируются непосредственно из рукописных документов, в названиях полей и в самих данных могут
присутствовать опечатки, а так же не существует никакого единого стандарта для именования тех или иных полей. Нужная информация
может находиться в поле, которое в каждой закупке будет называться по-разному.

#### Проблема 2. Возможные ограничения сайта

На данный момент ничего доподлинно неизвестно о защите сайта госзакупок от ботов. Если подобная защита имеется, придётся
обходить её при помощи разнообразных инструментов, среди которых:
- временные прокси
- подмена заголовков
- эмитация отпечатков браузера
и т.д.

### Возможные решения

#### Проблема 1

Для решения первой проблемы предлагается вести в базу данных таблицу названий всех полей, которые необходимы для парсинга.
Для этого предлагается разработоать модуль полуавтоматического выбора этих полей, работающий через командную строку. 
С помощью этого модуля таблица названий полей будет вручную заполняться при тестовом парсинге множества заявок.

#### Примеры работы

Например, поле с именем "Реестровый номер извещения" в другой закупке может называться просто "Реестровый номер", в третьей
же "Номер извещения". Необходимо спарсить вручную большой объём заявок, и занести все возможные варианты названий в таблицу
с названиями этого поля.

Для упрощения задачи на каждую новую заявку парсер должен автоматически определять те данные, которые уже присутствуют в
заполненных полях, оставляя для ручного выбора пользователю только те необходимые поля, которые ещё нельзя спарсить ввиду
отсутствия имени поля в таблице.

Например, первая заявка содержит поле "Реестровый номер извещения", пользователь определяет её вручную в поле с названием
"реестр" (переменная reestr), и оно попадает в таблицу базы, ассоциируясь с переменной reestr.

Вторая закупка содержит так же "Реестровый номер извещения", и данные из этого поля уже автоматически попадают в переменную
reestr, пользователю не нужно вручную определять тип поля.

Третья закупка содержит название "Реестровый номер", и такого названия в таблице ещё нет. Пользователь снова определяет
это название в поле "реестр" вручную, и после этого реестровый номер соотносится с переменной reestr.

Четвёртая заявка снова содержит поле "Реестровый номер", и оно автоматически определяется в reestr, так как поле присутствует
в таблице.

Пятая заявка содержит поле "Реестровый номер извещения", присутствующее в таблице, и оно снова определяется автоматически.

Шестая заявка содержит отсутствующее в таблице поле "Номер извещения", и пользователь снова вручную соотносит поле.

Если в дальнейших заявках будет содержаться только один из этих трёх вариантов, то парсинг этого поля будет осуществляться
автоматически. Если же имеется какой-либо иной вариант, парсер снова запросит определение поля вручную.

#### Проблема 2

Для определения примерного количества типовых запросов с одного IP необходимо при обучении модели парсингу разнообразных
полей (см. проблема 1) вести счётчик запросов. Если мы столкнёмся с блокировками со стороны сайта, необходимо продумать
обход блокировок в виде подмены заголовков, смены IP и других методов, используемых для ботов и парсеров. Необходимо будет
создать отдельные модули для подмены заголовков, смены IP, смены отпечатков браузера и т.д.
Необходимо будет подключение сторонних сервисов, выдающих новые IP по API.

В случае, если ограничений со стороны сайта zakupki.gov.ru не последует, данные меры не требуются.

## Часть 1. Парсинг по REST API

### Общие требования

Ввиду описанных выше проблем, логика работы парсера может быть простроена от простого к сложному. Сначала можно осуществить
парсинг ФЗ44, затем перейти к обработке ФЗ223 и обучению модели распознавания полей.

Парсер по REST API должен содержать:

- Главный модуль приложения (единый для Ч.1 (REST) и Ч.2 (GUI)):
    - Содержит роуты ко всем модулям всех версий
    - Имеет админку для просмотра ролей, БД и счётчиков запросов
    - Имеет стандартную страницу авторизации
    - Имеет пользователя с административными правами
    - Может создавать пользователей и назначать им роли
    - Каждая функция обрабатывает и логирует исключения
    - Получает от модуля токенов статус пользователя
    - Отправляет неавторизованным пользователям соответствующий статус

- Модуль для обработки REST-запросов:
    - Построен на библиотеке djangorestframework
    - Имеет версионирование
    - В названии модуля присутствует "rest" и версия (например, rest_v1.0.0)
    - Получает запросы непосредственно в командной строке и обрабатывает их
    - Отправляет результат обработки в главный модуль приложения для перенаправления в модули парсинга
    - Каждая функция обрабатывает и логирует исключения

- Модуль токенов:
    - Получает запрос со стороны модуля rest
    - Определяет уровни доступа клиента по API
    - Разделяет авторизованные и неавторизованные запросы при помощи middleware
    - Определяет авторизованного пользователя и его роль для генерации токена
    - Генерирует секретный токен доступа и кладёт его хэш в базу данных
    - Высылает на почту клиента секретный токен доступа при авторизации
    - Определяет статус пользователя и отдаёт его в главный модуль
    - Каждая функция обрабатывает и логирует исключения
    - Модуль следит за валидностью и временем действия токенов в базе

- Модуль подсчёта количества запросов:
    - Получает запрос на увеличение счётчика со стороны модуля парсинга
    - Определяет пользователя, для которого необходимо увеличить счётчик
    - Увеличивает счётчик запросов в базе данных
    - В случае отсутствия данного пользователя обрабатывает исключение

- Модуль парсинга ФЗ44:
    - Имеет версионирование согласно версионированию API
    - В названии модуля присутствует "parse44" и версия (например, parse44_v1.0.0)
    - Получает запросы через главный модуль приложения
    - Разделяет запросы при помощи middleware
    - Определяет переданный в GET номер закупки
    - Осуществляет парсинг закупки по данному номеру
    - В случае успеха возвращает клиенту JSON с данными закупки
    - Определяет, предполагает ли роль клиента ограничения по запросам
    - В случае успеха отправляет в модуль подсчёта запрос на увеличение счётчика запросов
    - В случае неудачи обрабатывает и логгирует исключения

- Модуль парсинга ФЗ223:
    - Имеет версионирование согласно версионированию API
    - В названии модуля присутствует "parse223" и версия (например, parse223_v1.0.0)
    - Получает запросы через главный модуль приложения
    - Разделяет запросы при помощи middleware
    - Определяет переданный в GET номер закупки
    - Осуществляет парсинг закупки по данному номеру
    - В случае успеха возвращает клиенту JSON с данными закупки
    - Определяет, предполагает ли роль клиента ограничения по запросам
    - В случае успеха отправляет в модуль подсчёта запрос на увеличение счётчика запросов
    - В случае неудачи обрабатывает и логгирует исключения

- Тестовый модуль для обучения парсера ФЗ223 (см. решение проблемы 1):
    - Получает запросы через главный модуль приложения
    - Разделяет запросы при помощи middleware
    - Определяет переданный в GET номер закупки
    - Осуществляет парсинг всех полей по номеру закупки
    - Даёт возможность пользователю распределить поля вручную через cli
    - В случае существования имени поля в базе парсит данные из поля автоматически
    - Определяет, предполагает ли роль клиента ограничения по запросам
    - В случае успеха отправляет в модуль подсчёта запрос на увеличение счётчика запросов
    - В случае неудачи обрабатывает и логгирует исключения

Так же можно использовать для предварительного определения типа ФЗ длинну идентификатора:
- 11 цифр - 223 ФЗ
- 19 црфр - 44 ФЗ
Или же проверять по условию: > 13 чисел - проверять сначала 44, < 13 - 223.


- Каждый модуль должен содержать все необходимые для миграций поля каждого представленного в БД класса.
- Конфигурация некоторых настроек может быть вынесена в отдельный файл конфигурации.
- Каждая функция, работающая с базой через CRUD должна использовать REST подход для работы с базой, например,
REST-запросу UPDATE должен соответствовать SQL-query UPDATE.
- Конфигурация приложения должна осуществляться при помощи файла конфигурации. 


### Логика работы приложения

1. Клиент отправляет запрос по API
2. Главный модуль определяет тип запроса
3. Главный модуль передаёт запрос модулю токенов
4. Модуль токенов определяет, имеет ли пользователь доступ
5. Модуль токенов отдаёт статус пользователя в главный модуль
6. Главный модуль распределяет запросы следующим образом:
- 6.1 Если пользователь авторизован, главный модуль определяет тип ФЗ
- 6.2 Если пользователь не авторизован, ему приходит соответствующий статус
- 6.3 Если тип ФЗ - 44, запрос направляется на parse44_v1.0.0
- 6.4 Если тип ФЗ - 223, запрос направляется на parse223_v1.0.0
- 6.5 Если тип ФЗ неизвестен, заявка получает статус "atypical" и направляется в парсер ФЗ44
7. Парсер ФЗ44 (parse44_v1.0.0) распределяет запросы следующим образом:
- 7.1 Если тип ФЗ известен, осуществляется парсинг и результат отдаётся клиенту
- 7.2 Еслм статус "atypical", отправляется запрос в ФЗ44 и результат зависит от успеха парсинга
- 7.3 Если ФЗ44 имеет соответствующую закупку, осуществляется парсинг, результат отдаётся клиенту
- 7.4 Если ФЗ44 не содержит такой закупки, результат направляется в модуль ФЗ223 (parse223_v1.0.0)
8. Парсер ФЗ223 (parse223_v1.0.0) имеет следующую логику:
- 8.1 Если запрос пришёл из главного модуля, осуществляется парсинг, результат возвращается клиенту
- 8.2 Если запрос пришёл из модуля ФЗ44, осуществляется парсинг, результат возвращается клиенту
- 8.3 Если какое-либо из полей не найдено по существующему запросу, логируется исключение
- 8.4 Недостающие поля заполняются значением "Null", результат возвращается клиенту
- 8.5 Номер заявки, имеющей недостающие поля, сохраняется в таблицу для дальнейшего улучшения

## Часть 2. Графический интерфейс пользователя

В случае успешной работы приложения, описанного в части первой, имеет смысл создание графического интерфейса.

Графический интерфейс может быть ориентирован на личный кабинет пользователя, позволяющий ему управлять своим тарифом.

### Общие требования

- Главная страница должна содержать:
    - Описание тарифов с количеством запросов / сроком / стоимостью подписки
    - Кнопку логина для регистрации пользователя
    - Поля ввода данных для регистрации
    - Кнопку входа для входа пользователя в личный кабинет
    - Кнопку "забыли пароль?" для восстановления пароля по электронной почте

- Личный кабинет может быть представлен одной простой страницей и должен содержать:
    - Информацию о выбранном тарифе
    - Информацию о сроках, когда данный тариф истекает
    - Счётчик запросов, позволяющий отследить количество сделанных запросов
    - Кнопку для оплаты (способ оплаты пока не продуман)

- Почтовый модуль:
    - При успешной регистрации модуль возвращает письмо с логином и паролем для авторизации
    - При оплате тарифа модуль возвращает валидный токен доступа
    - При смене пароля модуль отправляет на почту пользователя новый пароль
    - При восстановлении пароля модуль отправляет на почту пользователя новый пароль

## Часть 3. Логирование

- Необходимо реализовать логирование всех действий пользователя (файлы логов записывать в папку logs).
- Каждый день создается новый файл логов. Название файлов должно соответствовать шаблону *logs_dd-MM-yy-hh-mm-ss*
- Для логирования может быть использован модуль loguru

У каждой записи должен быть обозначен ее уровень важности:
- **Info**: ожидаемое событие;
- **Warning**: неожиданные события, которые позволяют продолжить работу приложения;
- **Error**: событие, которое не позволяет дальнейшую работу программы;

## Часть 4. Развертывание приложения

Подготовить приложение к запуску.
Для этого необходимо упаковать в docker-контейнеры:
- проксирующий сервер (использовать nginx)
- web приложение

Подготовить docker-compose для запуска всего приложения. При этом "наружу" должен смотреть только docker-контейнер, содержащий Nginx. 
